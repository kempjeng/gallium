// starting with a rust-like syntax since it is a known-quantity for
// functional features

package main

import (
    "fmt",
    "strings",
)


// C-like enums
enum Operator { Eq, Ne, Gt, Lt, Ge, Le }

impl Operator {
    fn Compile(self) -> string {
        match self {
            Operator::Eq => "==",
            Operator::Ne => "!=",
            Operator::Gt => ">",
            Operator::Lt => "<",
            Operator::Ge => ">=",
            Operator::Le => "<=",
        }
    }
}

// Sum-type, generic enums
enum Operand<V> { Variable V, Literal f64 }

// Interfaces can be used as traits, but traits are probably more general (can
// specify other types, for example)? We can certainly guarantee that
// interfaces *can* be monomorphized, but maybe there's something to be said
// for dynamic dispatch semantics ("interfaces *mean* dynamic dispatch")? In
// the worst case, we just define a Stringer trait.
impl<V> Operand<V: fmt.Stringer> {
    fn Compile(self) -> string {
        match self {
            Operand::Variable(v) => "\"" + v.String() + "\"",
            Operand::Literal(l) => fmt.FormatFloat(l, 'f', 64),
        }
    }
}

enum Expression<V> {
    Comparison {Left: Operand, Operator: Operator, Right: Operand},
    And Slice<Expression>,
    Or Slice<Expression>,
}

impl Expression {
    fn Compile(self) -> string {
        match self {
            Expression::Comparison{Left, Operator, Right} => fmt.Sprintf(
                "%s %s %s",
                Left.Compile(),
                Operator.Compile(),
                Right.Compile(),
            ),
            Expression::And(exprs) => "(" + strings.Join(
                exprs.map(Expression::Compile),
                " AND ",
            ) + ")",
            Expression::Or(exprs) => "(" + strings.Join(
                exprs.map(Expression::Compile),
                " OR ",
            ) + ")",
        }
    }
}
