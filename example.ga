// starting with a rust-like syntax since it is a known-quantity for
// functional features

package main

import (
    "fmt"
    "strings"
    "strconv"
)


// C-like enums
enum Operator { Eq, Ne, Gt, Lt, Ge, Le }

impl Operator {
    fn Compile(self) -> string {
        match self {
            Operator::Eq => "==",
            Operator::Ne => "!=",
            Operator::Gt => ">",
            Operator::Lt => "<",
            Operator::Ge => ">=",
            Operator::Le => "<=",
        }
    }
}

enum Literal {
    String string,
    Integer i64,
    Decimal f64,
}

impl Literal {
    fn Compile(self) -> string {
        match self {
            Literal::String(s) => "'" + s + "'",
            Literal::Integer(i) => strconv.Itoa(i),
            Literal::Decimal(d) => fmt.FormatFloat(d, 'f', 64),
        }
    }
}

trait Stringer { fn String(self) -> string }

// Sum-type, generic enums
enum Operand<V, L> { Variable V, Literal L}

impl<V> Operand<V: Stringer> {
    fn Compile(self) -> string {
        match self {
            Operand::Variable(v) => "\"" + v.String() + "\"",
            Operand::Literal(l) => l.Compile(),
        }
    }
}

enum Expression<V> {
    Comparison {Left: Operand, Operator: Operator, Right: Operand},
    And Slice<Expression>,
    Or Slice<Expression>,
}

impl Expression {
    fn Compile(self) -> string {
        match self {
            Expression::Comparison{Left, Operator, Right} => fmt.Sprintf(
                "%s %s %s",
                Left.Compile(),
                Operator.Compile(),
                Right.Compile(),
            ),
            Expression::And(exprs) => "(" + strings.Join(
                exprs.map(Expression::Compile),
                " AND ",
            ) + ")",
            Expression::Or(exprs) => "(" + strings.Join(
                exprs.map(Expression::Compile),
                " OR ",
            ) + ")",
        }
    }
}

impl Stringer for string {
    fn String(self) -> string { self }
}

fn main() {
    // `let` indicates an immutable binding
    let ridesForFree = Expression::Or{
        Expression::Comparison{
            Left: Operand::Variable("age"),
            Operator: Operator::Lt,
            Right: Operand::Literal(11),
        },
        Expression::Comparison{
            Left: Operand::Variable("age"),
            Operator: Operator::Ge,
            Right: Operand::Literal(65),
        },
    };
    fmt.Println(ridesForFree.Compile());
}
